<!DOCTYPE html>
<html>

<head>
  <link rel="stylesheet" href="/tufte.css" />
  <link rel="stylesheet" href="/github-embed.css" />
  <meta charset="utf-8">
  <title>Weekend Rustic Ray Tracing - Part 1</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/6.23.0/polyfill.min.js"></script>
  <script src="/github-embed.min.js"></script>

</head>

<body>
  <h1>Weekend Rustic Ray Tracing - Part 1</h1>
  <article>
<section>
<h2>Introduction</h2>
<p>If you're at all curious about ray tracing, I recommend starting with Peter Shirley's Ray Tracing Minibooks. In this
series of posts, I'll be converting the code in Ray Tracing in One Weekend (Book 1 in the series) to Rust. Rather than
rewrite Mr. Shirley's text, I'll be explaining my implementation choices.</p>
<p>Each chapter has its own branch: <code>Chapter01</code>, <code>Chapter02</code>, etc. Each chapter branch is the completed code for that
chapter. The <code>master</code> branch will be the final renderer from the end of the book.</p>
<p>This little project will then be followed with some modifications to allow the code to render in a web browser.</p>
</section>
<section>
<h3>Chapter 1: Output an image</h3>
<p>Checkout <code>Chapter01</code> and read <code>main.rs</code>. This first chapter is straitforward: output some formatted text. As much as I loves me some operator overloading, I
really dislike the C++ standard library's use of the left shift operator (<code>&lt;&lt;</code>) to 'push' things onto a stream. In Rust
land, I'll be using format strings and passing arguments to fill in the blanks.</p>
<p>The header of the image file is specified in a single line just like the C++ code. Rust looks a bit more succint in
this case.</p>
<pre style="background-color:#3b3228;">
<span style="background-color:#3b3228;color:#d0c8c6;">
</span><span style="background-color:#3b3228;color:#d0c8c6;">    </span><span style="background-color:#3b3228;color:#d0c8c6;">print!(&quot;</span><span style="background-color:#3b3228;color:#beb55b;">P3</span><span style="background-color:#3b3228;color:#7bbda4;">\n</span><span style="background-color:#3b3228;color:#d28b71;">{} {}</span><span style="background-color:#3b3228;color:#7bbda4;">\n</span><span style="background-color:#3b3228;color:#beb55b;">255</span><span style="background-color:#3b3228;color:#7bbda4;">\n</span><span style="background-color:#3b3228;color:#d0c8c6;">&quot;, nx, ny);
</span><span style="background-color:#3b3228;color:#d0c8c6;">
</span></pre>
<p>I chose the <code>f32</code> type for no particular reason. As I'm using this exercise to start learning Rust, I'm almost
transliterating the C++ code. If there's a better/nicer way to cast types or truncate to integers, I haven't learned it
yet.</p>
<p>The C++ code looks like a typical <code>for</code> where the 'incrementer' decrements, and the condition just needs to check for
the minimum (0 in this case.) In Rust, we'll let the standard library reverse the list for us to traverse.</p>
<pre style="background-color:#3b3228;">
<span style="background-color:#3b3228;color:#d0c8c6;">
</span><span style="background-color:#3b3228;color:#d0c8c6;">    </span><span style="background-color:#3b3228;color:#a89bb9;">for</span><span style="background-color:#3b3228;color:#d0c8c6;"> j in (</span><span style="background-color:#3b3228;color:#d28b71;">0</span><span style="background-color:#3b3228;color:#d0c8c6;">..ny).</span><span style="background-color:#3b3228;color:#7bbda4;">rev</span><span style="background-color:#3b3228;color:#d0c8c6;">() {
</span><span style="background-color:#3b3228;color:#d0c8c6;">
</span></pre>
<p>The inner loop is nothing special, just iterate over the values in the (half-open) <code>Range</code> specified by <code>(0..nx)</code>.</p>
<pre style="background-color:#3b3228;">
<span style="background-color:#3b3228;color:#d0c8c6;">
</span><span style="background-color:#3b3228;color:#d0c8c6;">    </span><span style="background-color:#3b3228;color:#a89bb9;">for</span><span style="background-color:#3b3228;color:#d0c8c6;"> j in (</span><span style="background-color:#3b3228;color:#d28b71;">0</span><span style="background-color:#3b3228;color:#d0c8c6;">..ny).</span><span style="background-color:#3b3228;color:#7bbda4;">rev</span><span style="background-color:#3b3228;color:#d0c8c6;">() {
</span><span style="background-color:#3b3228;color:#d0c8c6;">
</span></pre>
<p>Finally, output the line representing the current pixel.</p>
<pre style="background-color:#3b3228;">
<span style="background-color:#3b3228;color:#d0c8c6;">
</span><span style="background-color:#3b3228;color:#d0c8c6;">    </span><span style="background-color:#3b3228;color:#d0c8c6;">print!(&quot;</span><span style="background-color:#3b3228;color:#d28b71;">{} {} {}</span><span style="background-color:#3b3228;color:#7bbda4;">\n</span><span style="background-color:#3b3228;color:#d0c8c6;">&quot;, ir, ig, ib);
</span><span style="background-color:#3b3228;color:#d0c8c6;">
</span></pre></section>
</article>

</body>

</html>